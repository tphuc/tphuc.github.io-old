{"pageProps":{"frontMatter":{"title":"The best framework for React - Nextjs.","description":"An introduction about the React's infamous framework","date":"June 29, 2022","thumbnail":"images/29.jpeg"},"slug":"the-best-framework-for-React","mdxSource":{"compiledSource":"var u=Object.defineProperty,c=Object.defineProperties;var m=Object.getOwnPropertyDescriptors;var r=Object.getOwnPropertySymbols;var s=Object.prototype.hasOwnProperty,o=Object.prototype.propertyIsEnumerable;var l=(a,t,i)=>t in a?u(a,t,{enumerable:!0,configurable:!0,writable:!0,value:i}):a[t]=i,e=(a,t)=>{for(var i in t||(t={}))s.call(t,i)&&l(a,i,t[i]);if(r)for(var i of r(t))o.call(t,i)&&l(a,i,t[i]);return a},p=(a,t)=>c(a,m(t));var d=(a,t)=>{var i={};for(var n in a)s.call(a,n)&&t.indexOf(n)<0&&(i[n]=a[n]);if(a!=null&&r)for(var n of r(a))t.indexOf(n)<0&&o.call(a,n)&&(i[n]=a[n]);return i};const layoutProps={},MDXLayout=\"wrapper\";function MDXContent(i){var n=i,{components:a}=n,t=d(n,[\"components\"]);return mdx(MDXLayout,p(e(e({},layoutProps),t),{components:a,mdxType:\"MDXLayout\"}),mdx(\"p\",null,\"If React is a UI/state library, then Nextjs tells us how to use the library the \",mdx(\"strong\",{parentName:\"p\"},\"right\"),` way to build fast web application also it makes your development process much easier.\nThis post is an introduction to Nextjs, with few examples below to quickly showcase Nextjs features and how it is very easy to use Nextjs for React.`),mdx(\"h1\",null,\"Routing done easy\"),mdx(\"p\",null,`One of the building blocks of web apps is routing. I worked on many React apps in the past, before NextJs, people \"freestyle\" on choosing the project's folder structure and naming conventions, how to do routing, etc... Every project have a slightly different file structures since there is really no universal standard,\nwhich makes it sometimes hard to read.`),mdx(\"p\",null,\"Now in Nextjs, it will automatically handle routing for you, simply create files under \",mdx(\"inlineCode\",{parentName:\"p\"},\"/pages\"),\" folder and export it as default.\"),mdx(\"pre\",null,mdx(\"code\",e({parentName:\"pre\"},{className:\"language-jsx\"}),`    pages/\n    |---> index.js\n    |---> about.js\n    |---> dashboard/\n          |---> index.js\n          |---> users.js\n`)),mdx(\"p\",null,\"Then your site will be accessible at\"),mdx(\"pre\",null,mdx(\"code\",e({parentName:\"pre\"},{}),`    /\n    /about\n    /dashboard\n    /dashboard/users\n`)),mdx(\"h1\",null,\"Dynamic Routes\"),mdx(\"p\",null,\"Nextjs supports dynamic pages routing, for example you created file structures like this\"),mdx(\"pre\",null,mdx(\"code\",e({parentName:\"pre\"},{}),`    pages/\n    |---> users/\n          |---> [userId].js\n`)),mdx(\"p\",null,\"Then your site will be accessible at \",mdx(\"inlineCode\",{parentName:\"p\"},\"pages/users/1\"),\", \",mdx(\"inlineCode\",{parentName:\"p\"},\"pages/users/2\"),`, ...\nMatched parameters will be sent as a query parameter (`,mdx(\"inlineCode\",{parentName:\"p\"},\"userId\"),\" in the example) to the page.\"),mdx(\"pre\",null,mdx(\"code\",e({parentName:\"pre\"},{className:\"language-jsx\",metastring:\"file=pages/user/[userId].jsx\",file:\"pages/user/[userId].jsx\"}),`    import {useRouter} from 'next/router'\n\n    export default () => {\n        const { userId } = useRouter().query\n        return ...\n    }\n\n`)),mdx(\"p\",null,\"For more read on \",mdx(\"a\",e({parentName:\"p\"},{href:\"https://nextjs.org/docs/routing/dynamic-routes\"}),\"Dynamic Routing Nextjs\")),mdx(\"h1\",null,\"Per-page layouts\"),mdx(\"p\",null,`Sometimes your screens/pages share some part of the UI. It is a good practice to seperate the layout component to help yourself repeating.\nFor example we have 2 pages that share the same layout.`),mdx(\"p\",null,mdx(\"inlineCode\",{parentName:\"p\"},\"/page-a\")),mdx(\"div\",{style:{display:\"grid\",gridTemplateColumns:\"20% 1fr\",width:\"100%\",gridGap:5,height:260,background:\"inherit\",borderRadius:7}},mdx(\"div\",{style:{background:\"#faa\",display:\"flex\",alignItems:\"center\",justifyContent:\"center\",borderRadius:5}},\"Side Bar\"),mdx(\"div\",{style:{background:\"#aaf\",display:\"flex\",alignItems:\"center\",justifyContent:\"center\",borderRadius:5}},\"Page A\")),mdx(\"p\",null,mdx(\"inlineCode\",{parentName:\"p\"},\"/page-b\")),mdx(\"div\",{style:{display:\"grid\",gridTemplateColumns:\"20% 1fr\",width:\"100%\",gridGap:5,height:260,background:\"inherit\",borderRadius:7}},mdx(\"div\",{style:{background:\"#faa\",display:\"flex\",alignItems:\"center\",justifyContent:\"center\",borderRadius:5}},\"Side Bar\"),mdx(\"div\",{style:{background:\"#aaf\",display:\"flex\",alignItems:\"center\",justifyContent:\"center\",borderRadius:5}},\"Page B\")),mdx(\"p\",null,\"Create \",mdx(\"inlineCode\",{parentName:\"p\"},\"DashboardLayout\")),mdx(\"pre\",null,mdx(\"code\",e({parentName:\"pre\"},{className:\"language-jsx\",metastring:\"file=layouts/dashboard-layout.js\",file:\"layouts/dashboard-layout.js\"}),`import SideBar from '../components/SideBar'\n\nexport default DashboardLayout({ content }){\n    return <div style={{display:\"grid\", gridTemplateColumns:\"20% 1fr\"}}>\n        <SideBar/>\n        {content}\n    </div>\n}\n`)),mdx(\"p\",null,\"Adding property \",mdx(\"inlineCode\",{parentName:\"p\"},\"getLayout\"),\" to your pages.\"),mdx(\"pre\",null,mdx(\"code\",e({parentName:\"pre\"},{className:\"language-jsx\",metastring:\"file=pages/page-a.js\",file:\"pages/page-a.js\"}),`import DashboardLayout from '../layouts/dashboard-layout'\n\nexport default function PageA() {\n    return <div>\n        PageA\n    </div>\n}\n\nPageA.getLayout = (page) => {\n  return (\n    <DashboardLayout>\n        {page}\n    </DashboardLayout>\n  )\n}\n`)),mdx(\"pre\",null,mdx(\"code\",e({parentName:\"pre\"},{className:\"language-jsx\",metastring:\"file=pages/page-b.js\",file:\"pages/page-b.js\"}),`import DashboardLayout from '../layouts/dashboard-layout'\n\nexport default function PageB() {\n    return <div>\n        PageB\n    </div>\n}\n\nPageB.getLayout = (page) => {\n  return (\n    <DashboardLayout>\n        {page}\n    </DashboardLayout>\n  )\n}\n`)),mdx(\"p\",null,\"When using Next.js you\\u2019ll most likely need to override the global App component to get access to some features like persisting state, global css or layouts. This can be done by creating a file \",mdx(\"inlineCode\",{parentName:\"p\"},\"_app.js\"),\" directly under the \",mdx(\"inlineCode\",{parentName:\"p\"},\"pages/\"),\" folder. In your \",mdx(\"inlineCode\",{parentName:\"p\"},\"pages/_app.js\")),mdx(\"pre\",null,mdx(\"code\",e({parentName:\"pre\"},{className:\"language-jsx\",metastring:\"file=pages/_app.js\",file:\"pages/_app.js\"}),`export default function MyApp({ Component, pageProps }) {\n    // Use the layout defined at the page level, if available\n    const getLayout = Component.getLayout || ((page) => page)\n    return <>\n        {getLayout(<Component {...pageProps} />)}\n    </>\n}\n`)),mdx(\"p\",null,\"This layout pattern enables state persistence because the React component tree is maintained between page transitions. For more read on \",mdx(\"a\",e({parentName:\"p\"},{href:\"https://nextjs.org/docs/basic-features/layouts#per-page-layouts\"}),\"official docs\")),mdx(\"h1\",null,\"getServerSideProps\"),mdx(\"p\",null,`If you export an async function called getServerSideProps from a page,\nNextjs will pre-render this page on each request using the data returned by getServerSideProps.`),mdx(\"pre\",null,mdx(\"code\",e({parentName:\"pre\"},{className:\"language-jsx\",metastring:\"file=pages/user/[id].js\",file:\"pages/user/[id].js\"}),`export async function getServerSideProps(context) {\n    const { params, locale} = context;\n    const res = await fetchUserDataById(params.id) // fetch data from database\n    return {\n        props: {\n            userData: res?.data\n            locale\n        }, // will be passed to the page component as props\n    }\n}\n\nexport default function User(props){ \n    const { userData, locale } = props; // <-- props received from getServerSideProps\n    return <>\n        ...\n    </>\n}\n\n`)),mdx(\"p\",null,\"The \",mdx(\"inlineCode\",{parentName:\"p\"},\"context\"),\" parameter is an object containing the following keys:\"),mdx(\"ul\",null,mdx(\"li\",{parentName:\"ul\"},mdx(\"inlineCode\",{parentName:\"li\"},\"params\"),\": If this page uses a dynamic route, params contains the route parameters. If the page name is \",\"[id]\",\".js , then params will look like { id: ... }.\"),mdx(\"li\",{parentName:\"ul\"},mdx(\"inlineCode\",{parentName:\"li\"},\"req\"),\": The HTTP IncomingMessage object, with an additional cookies prop, which is an object with string keys mapping to string values of cookies.\"),mdx(\"li\",{parentName:\"ul\"},mdx(\"inlineCode\",{parentName:\"li\"},\"res\"),\": The HTTP response object.\"),mdx(\"li\",{parentName:\"ul\"},mdx(\"inlineCode\",{parentName:\"li\"},\"query\"),\": An object representing the query string.\"),mdx(\"li\",{parentName:\"ul\"},mdx(\"inlineCode\",{parentName:\"li\"},\"preview\"),\": preview is true if the page is in the Preview Mode and false otherwise.\"),mdx(\"li\",{parentName:\"ul\"},mdx(\"inlineCode\",{parentName:\"li\"},\"previewData\"),\": The preview data set by setPreviewData.\"),mdx(\"li\",{parentName:\"ul\"},mdx(\"inlineCode\",{parentName:\"li\"},\"resolvedUrl\"),\": A normalized version of the request URL that strips the _next/data prefix for client transitions and includes original query values.\"),mdx(\"li\",{parentName:\"ul\"},mdx(\"inlineCode\",{parentName:\"li\"},\"locale\"),\" contains the active locale (if enabled).\"),mdx(\"li\",{parentName:\"ul\"},mdx(\"inlineCode\",{parentName:\"li\"},\"locales\"),\" contains all supported locales (if enabled).\"),mdx(\"li\",{parentName:\"ul\"},mdx(\"inlineCode\",{parentName:\"li\"},\"defaultLocale\"),\" contains the configured default locale (if enabled).\")),mdx(\"h1\",null,\"getStaticProps\"),mdx(\"p\",null,\"Nextjs will pre-render this page at build time using the data returned by getServerSideProps. \"),mdx(\"pre\",null,mdx(\"code\",e({parentName:\"pre\"},{className:\"language-jsx\",metastring:\"file=pages/user/[id].js\",file:\"pages/user/[id].js\"}),`export async function getStaticProps() {\n    const { params, locale} = context;\n    // Call an external API endpoint to get data\n    const userData = await await fetch(\\`https://.../user/\\${params.id}\\`).then(res => res.json()); \n    return {\n        props: {\n            userData,\n            locale\n        }, // will be passed to the page component as props\n    }\n}\n\nexport default function User(props){ \n    const { userData, locale } = props; // <-- props received from getServerSideProps\n    return <>\n        ...\n    </>\n}\n`)),mdx(\"p\",null,\"The context parameter is an object containing the following keys:\"),mdx(\"ul\",null,mdx(\"li\",{parentName:\"ul\"},mdx(\"inlineCode\",{parentName:\"li\"},\"params\"),\" contains the route parameters for pages using dynamic routes. For example, if the page name is \",\"[id]\",\".js , then params will look like { id: ... }. You should use this together with getStaticPaths, which we\\u2019ll explain later.\"),mdx(\"li\",{parentName:\"ul\"},mdx(\"inlineCode\",{parentName:\"li\"},\"preview\"),\" is true if the page is in the Preview Mode and undefined otherwise.\"),mdx(\"li\",{parentName:\"ul\"},mdx(\"inlineCode\",{parentName:\"li\"},\"previewData\"),\" contains the preview data set by \",mdx(\"inlineCode\",{parentName:\"li\"},\"setPreviewData\"),\".\"),mdx(\"li\",{parentName:\"ul\"},mdx(\"inlineCode\",{parentName:\"li\"},\"locale\"),\" contains the active locale (if enabled).\"),mdx(\"li\",{parentName:\"ul\"},mdx(\"inlineCode\",{parentName:\"li\"},\"locales\"),\" contains all supported locales (if enabled).\"),mdx(\"li\",{parentName:\"ul\"},mdx(\"inlineCode\",{parentName:\"li\"},\"defaultLocale\"),\" contains the configured default locale (if enabled).\")),mdx(\"p\",null,\"Wait, it is doing the same as \",mdx(\"inlineCode\",{parentName:\"p\"},\"getServerSideProps\"),\" ? Yes, both functions passed some props to the page, but there are few differences to consider.\"),mdx(\"p\",null,mdx(\"inlineCode\",{parentName:\"p\"},\"getServerSideProps\")),mdx(\"ul\",null,mdx(\"li\",{parentName:\"ul\"},\"This function get called every time you visit the site, the server will have to build the page every time each request.\"),mdx(\"li\",{parentName:\"ul\"},\"Can be slow\"),mdx(\"li\",{parentName:\"ul\"},\"Great for dynamic data that changes regularly\")),mdx(\"p\",null,mdx(\"inlineCode\",{parentName:\"p\"},\"getStaticProps\")),mdx(\"ul\",null,mdx(\"li\",{parentName:\"ul\"},\"This function get called only once at build time. Props remain the same until the next build.\"),mdx(\"li\",{parentName:\"ul\"},\"Great for speed and SEO\"),mdx(\"li\",{parentName:\"ul\"},\"Great for static data\")),mdx(\"h1\",null,\"getStaticPaths\"),mdx(\"p\",null,\"Assume you are building a blog site. You want to pre-render your articles as static pages for fast serving and better SEO.\"),mdx(\"pre\",null,mdx(\"code\",e({parentName:\"pre\"},{className:\"language-jsx\",metastring:\"file=pages/articles/[slug].js\",file:\"pages/articles/[slug].js\"}),`export async function getStaticPaths() {\n  // Read the files inside the pages/posts dir\n  const articles = await fetch('https://.../articles').then(res => res.json());\n    //   articles = [\n    //     {\n    //         id:\"1\",\n    //         title:\"hello-world\"\n    //     },\n    //     {\n    //         id:\"2\",\n    //         title:\"data-fetching-in-react\"\n    //     }\n    //   ]\n\n  // Generate path for each file\n  const paths = articles.map((article) => {\n    return {\n      params: {\n        slug: article.id\n      },\n    };\n  });\n\n  return {\n    paths,\n    fallback: false,\n  };\n}\n`)),mdx(\"p\",null,`The value for each params object must match the parameters used in the page name.\nIf the page name is `,mdx(\"inlineCode\",{parentName:\"p\"},\"articles/[slug].js\"),\", then params should contain \",mdx(\"inlineCode\",{parentName:\"p\"},\"slug\"),\".\"),mdx(\"p\",null,\"This function run once at build time and can be used altogether with \",mdx(\"inlineCode\",{parentName:\"p\"},\"getStaticProps\"),\" but can not be used with \",mdx(\"inlineCode\",{parentName:\"p\"},\"getServerSideProps\"),\". For more read on \",mdx(\"a\",e({parentName:\"p\"},{href:\"https://nextjs.org/docs/api-reference/data-fetching/get-static-paths\"}),\"official docs\")),mdx(\"pre\",null,mdx(\"code\",e({parentName:\"pre\"},{className:\"language-jsx\",metastring:\"file=pages/post/[id].js\",file:\"pages/post/[id].js\"}),`export default function Post({ post }) {\n  // Render post...\n}\n\n// This function gets called at build time\nexport async function getStaticPaths() {\n  // Call an external API endpoint to get posts\n  const posts = await fetch('https://.../posts').then(res => res.json())\n\n  // Get the paths we want to pre-render based on posts\n  const paths = posts.map((post) => ({\n    params: { id: post.id },\n  }))\n\n  // We'll pre-render only these paths at build time.\n  // { fallback: false } means other routes should 404.\n  return { paths, fallback: false }\n}\n\n// This also gets called at build time\nexport async function getStaticProps({ params }) {\n  // params contains the post \\`id\\`.\n  // If the route is like /posts/1, then params.id is 1\n  const post = await fetch(\\`https://.../posts/\\${params.id}\\`).then(res => res.json())\n\n  // Pass post data to the page via props\n  return { props: { post } }\n}\n`)),mdx(\"h1\",null,\"Conclusion\"),mdx(\"p\",null,\"Nextjs is a great framework for React. If you are React developer, you must know Nextjs. With all the great features and tools Nextjs provided, it saves your time and make your life easier, why not give it a try? \"),mdx(\"p\",null,\"Are there any alternatives to Nextjs ? Yes, checkout \",mdx(\"a\",e({parentName:\"p\"},{href:\"https://remix.run\"}),\"Remix.run\"),\". Remix is a relatively new framework compared to Nextjs, and it's built on top ReactRouterV6.\"),mdx(\"p\",null,\"Checkout  \",mdx(\"a\",e({parentName:\"p\"},{href:\"https://nextjs.org\"}),\"offical Nextjs\"),\" website.\"))}MDXContent.isMDXComponent=!0;\n","scope":{}},"readTime":7.095},"__N_SSG":true}