{"pageProps":{"frontMatter":{"title":"Data fetching in React with SWR","description":"A guide through remote data fetching in React with SWR hooks.","date":"Feburary 1, 2022","tags":["react","library","hook"],"level":"Intermediate","thumbnail":"images/data-fetching-with-swr.png"},"slug":"data-fetching-in-React","mdxSource":{"compiledSource":"var p=Object.defineProperty,u=Object.defineProperties;var h=Object.getOwnPropertyDescriptors;var r=Object.getOwnPropertySymbols;var s=Object.prototype.hasOwnProperty,i=Object.prototype.propertyIsEnumerable;var l=(t,a,n)=>a in t?p(t,a,{enumerable:!0,configurable:!0,writable:!0,value:n}):t[a]=n,e=(t,a)=>{for(var n in a||(a={}))s.call(a,n)&&l(t,n,a[n]);if(r)for(var n of r(a))i.call(a,n)&&l(t,n,a[n]);return t},c=(t,a)=>u(t,h(a));var d=(t,a)=>{var n={};for(var o in t)s.call(t,o)&&a.indexOf(o)<0&&(n[o]=t[o]);if(t!=null&&r)for(var o of r(t))a.indexOf(o)<0&&i.call(t,o)&&(n[o]=t[o]);return n};const layoutProps={},MDXLayout=\"wrapper\";function MDXContent(n){var o=n,{components:t}=o,a=d(o,[\"components\"]);return mdx(MDXLayout,c(e(e({},layoutProps),a),{components:t,mdxType:\"MDXLayout\"}),mdx(\"p\",null,`Fetching data is common task in every web application, basically you retrieve some information from your server to update some part of the UI of your webpage without having to reload the whole page.\nToday we will have a look at SWR - a react hook library for data fetching in React.`),mdx(\"h2\",null,\"Problem Without SWR\"),mdx(\"p\",null,`Traditionally, this is how you do fetching data inside a React component in the most basic form.\nFor this example, we have a function `,mdx(\"inlineCode\",{parentName:\"p\"},\"fetchAllDogs\"),\" somewhere that retrieves a list of all \",mdx(\"inlineCode\",{parentName:\"p\"},\"dogs\"),\" from server and display it.\"),mdx(\"pre\",null,mdx(\"code\",e({parentName:\"pre\"},{className:\"language-jsx\",metastring:\"{7-11,15}\",\"{7-11,15}\":!0}),`import List from 'components/List'\n\n\nconst Screen = () => {\n    const [dogs, setDogs] = React.useState();\n    \n    const fetchDogs = async () => {\n        // fetch from the server and update the state\n        let { data } = await fetch(\\`/all-dogs\\`).then(r => r.json());\n        setDogs(data);\n    }\n\n    // runs after first render\n    React.useEffect(() => {\n        fetchDogs()\n    }, [])\n\n    return (\n        <div>\n            <List data={dogs} >\n        </div>\n    )\n}\n`)),mdx(\"p\",null,`Now we want to improve the UX a little bit, add some loading indicator during fetching.\nWe create new variable state holds boolean value which indicates the loading state (true/false)`),mdx(\"pre\",null,mdx(\"code\",e({parentName:\"pre\"},{className:\"language-jsx\",metastring:\"{5,8,11,21}\",\"{5,8,11,21}\":!0}),`import List from 'components/List'\n\nconst Screen = () => {\n    const [dogs, setDogs] = React.useState();\n    const [loading, setLoading] = React.useState(false); // initial = false\n\n    const fetchDogs = async () => {\n        setLoading(true);  // before fetching\n        let { data } = await fetch(\\`/all-dogs\\`).then(r => r.json()));\n        setDogs(data);\n        setLoading(false);  // finish fetching\n    }\n\n    // runs after first render\n    React.useEffect(() => {\n        fetchDogs()\n    }, [])\n\n    return (\n        <div>\n            {loading ? 'fetching dogs...' : <List data={dogs} >}\n        </div>\n    )\n}\n`)),mdx(\"p\",null,\"What if an error occured during fetching \",mdx(\"inlineCode\",{parentName:\"p\"},\"fetchAllDogs()\"),\" and we want to display the error message returned by the server.\"),mdx(\"pre\",null,mdx(\"code\",e({parentName:\"pre\"},{className:\"language-jsx\",metastring:\"{6,12,26}\",\"{6,12,26}\":!0}),`import List from 'components/List'\n\nconst Screen = () => {\n    const [dogs, setDogs] = React.useState();\n    const [loading, setLoading] = React.useState(false); // initial = false\n    const [errMsg, setErrMsg] = React.useState(\"\");\n\n    const fetchDogs = async () => {\n        setLoading(true);  // before fetching\n        try {\n            let { data } = await fetch(\\`/all-dogs\\`).then(r => r.json());\n            setDogs(data);\n        }\n        catch(err){\n            setErrMsg(err)\n        }\n        setLoading(false);  // finish fetching\n    }\n\n    // runs after first render\n    React.useEffect(() => {\n        fetchDogs()\n    }, [])\n\n    return (\n        <div>\n            {errMsg ? errMsg : (loading ? 'fetching dogs...' : <List data={dogs} >)}\n        </div>\n    )\n}\n`)),mdx(\"p\",null,\"Now consider this\"),mdx(\"ul\",null,mdx(\"li\",{parentName:\"ul\"},mdx(\"p\",{parentName:\"li\"},\"What if you screen want to display the \",mdx(\"inlineCode\",{parentName:\"p\"},\"cats\"),\" not just only \",mdx(\"inlineCode\",{parentName:\"p\"},\"dogs\"),\", do we have to go through the same process and create more \",mdx(\"inlineCode\",{parentName:\"p\"},\"useState\"),\" variables as well ?\"),mdx(\"pre\",{parentName:\"li\"},mdx(\"code\",e({parentName:\"pre\"},{className:\"language-jsx\"}),`        ...\n        <List data={dogs} >\n        <List data={cats} >\n`))),mdx(\"li\",{parentName:\"ul\"},mdx(\"p\",{parentName:\"li\"},\"What if you have another \",mdx(\"inlineCode\",{parentName:\"p\"},\"ScreenB\"),\" that wants to display the \",mdx(\"inlineCode\",{parentName:\"p\"},\"dogs\"),\" as well, do we have to write all the same code over again ?\"),mdx(\"pre\",{parentName:\"li\"},mdx(\"code\",e({parentName:\"pre\"},{className:\"language-jsx\"}),`    const ScreenA = () => {\n        ...\n        return <List data={dogs} />\n    }\n\n    const ScreenB = () => {\n        ...\n        return <List data={dogs} />\n    }\n`)))),mdx(\"p\",null,\"Eventually our code is a bunch of mess! What is the solution for this \\u{1F914}?\"),mdx(\"h2\",null,\"With SWR hook\"),mdx(\"p\",null,\"What we want is to actually move all of the fetching code with the states variable into a hook function. Click \",mdx(\"a\",e({parentName:\"p\"},{href:\"https://reactjs.org/docs/hooks-overview.html\"}),\"here\"),\" if you want to read more about React Hooks. \"),mdx(\"pre\",null,mdx(\"code\",e({parentName:\"pre\"},{className:\"language-jsx\"}),`const {data, loading, errMsg } = useDogs();\n`)),mdx(\"p\",null,\"We will use \",mdx(\"inlineCode\",{parentName:\"p\"},\"swr\"),\" to implement the function \",mdx(\"inlineCode\",{parentName:\"p\"},\"useDogs\"),\". Firstly install \",mdx(\"inlineCode\",{parentName:\"p\"},\"swr\"),\" via \",mdx(\"inlineCode\",{parentName:\"p\"},\"yarn add swr\"),\" or \",mdx(\"inlineCode\",{parentName:\"p\"},\"npm install swr\"),`.\nFor best practices, we will create the function in another file and export it out.`),mdx(\"pre\",null,mdx(\"code\",e({parentName:\"pre\"},{className:\"language-jsx\",metastring:\"file=swr/use-dogs.js\",file:\"swr/use-dogs.js\"}),`import useSWR from 'swr'\n\nconst fetcher = async (url) => {\n    const { data } = await fetch(url).then(r => r.json());\n    return data;\n}\n\nexport default function useDogs() {\n    const { data, error, mutate } = useSWR('/get-dogs', fetcher)\n\n    return {\n        data: data,\n        loading: !error && !data,\n        errMsg: error,\n        mutate\n    }\n}\n`)),mdx(\"p\",null,\"This function is pretty straight forward. Let's me explain:\"),mdx(\"ul\",null,mdx(\"li\",{parentName:\"ul\"},\"First param of \",mdx(\"inlineCode\",{parentName:\"li\"},\"useSWR\"),\" will be the arguments of \",mdx(\"inlineCode\",{parentName:\"li\"},\"fetcher\"),\".\",mdx(\"pre\",{parentName:\"li\"},mdx(\"code\",e({parentName:\"pre\"},{className:\"language-js\"}),`    // this is equivalent\n    const { data, error, mutate } = useSWR(['/get-dogs'], \n        (url) => fetch(url).then(r => r.json())\n    )\n`))),mdx(\"li\",{parentName:\"ul\"},\"SWR automatically do the error handling for us. If an error is thrown inside \",mdx(\"inlineCode\",{parentName:\"li\"},\"fetcher\"),\", it will be returned as error by the hook.\"),mdx(\"li\",{parentName:\"ul\"},\"If you want to pass in multiple arguments\",mdx(\"pre\",{parentName:\"li\"},mdx(\"code\",e({parentName:\"pre\"},{className:\"language-js\"}),`    const { data, error, mutate } = useSWR(['/get-dogs', 1], \n        // fetch from /get-dogs/1\n        (url, id) => fetch(url + \\`/\\${id}\\`).then(r => r.json())\n    )\n`)))),mdx(\"p\",null,\"Now we have the \",mdx(\"inlineCode\",{parentName:\"p\"},\"useDogs\"),\" hooks with \",mdx(\"inlineCode\",{parentName:\"p\"},\"swr\"),\", let's rewrite our \",mdx(\"inlineCode\",{parentName:\"p\"},\"Screen\"),\".\"),mdx(\"pre\",null,mdx(\"code\",e({parentName:\"pre\"},{className:\"language-jsx\"}),`import useDogs from 'swr/use-dogs'\nimport List from 'componets/List'\n\nconst Screen = () => {\n    const { data, loading, errMsg, mutate } = useDogs();\n    return (\n        <div>\n            {loading && 'loading...'}\n            {errMsg && \\`an error occured: \\${errMsg}\\`}\n            {data && <List data={data} >}\n        </div>\n    )\n}\n\n`)),mdx(\"p\",null,\"As you may have noticed our function hook returns more than just data, loading and error, it also returns \",mdx(\"inlineCode\",{parentName:\"p\"},\"mutate\"),\". What is \",mdx(\"inlineCode\",{parentName:\"p\"},\"mutate\"),`?\n`,mdx(\"a\",e({parentName:\"p\"},{href:\"https://swr.vercel.app/docs/mutation\"}),mdx(\"inlineCode\",{parentName:\"a\"},\"mutate\")),\" is a special function can update your local data programmatically, while revalidating and finally replace it with the latest data. For example you may want to refetch the data after certain actions. Let's create a button that trigger refetching:\"),mdx(\"pre\",null,mdx(\"code\",e({parentName:\"pre\"},{className:\"language-jsx\"}),`...\nconst Screen = () => {\n    const { data, mutate } = useDogs();\n    return <>\n        <List data={data}>\n        <button onClick={() => {\n            mutate() // refetch the data\n        }}>\n            Refetch\n        </button>\n    </>\n}\n`)),mdx(\"p\",null,\"Write the hook function once, use anywhere, no need to rewrite all the code again, keeping it clean.\"),mdx(\"pre\",null,mdx(\"code\",e({parentName:\"pre\"},{className:\"language-jsx\"}),`...\nconst ScreenA = () => {\n    const { data, mutate } = useDogs();\n    ...\n}\n\nconst ScreenB = () => {\n    const { data, mutate } = useDogs();\n    ...\n}\n`)),mdx(\"p\",null,\"Write the hook function once, use anywhere, no need to rewrite all the code again, keeping it clean.\"),mdx(\"pre\",null,mdx(\"code\",e({parentName:\"pre\"},{className:\"language-jsx\"}),`...\nconst ScreenA = () => {\n    const { data, mutate } = useDogs();\n    ...\n}\n\nconst ScreenB = () => {\n    const { data, mutate } = useDogs();\n    ...\n}\n`)),mdx(\"p\",null,\"You can rename the unpack values using destructuring assignment syntax.\"),mdx(\"pre\",null,mdx(\"code\",e({parentName:\"pre\"},{className:\"language-jsx\"}),`...\nconst ScreenA = () => {\n    const { data: dogs, mutate: mutateDogs } = useDogs();\n    const { data: cats, mutate: mutateCats } = useCats();\n    return <>\n        <List data={dogs}>\n        <List data={cats}>\n    </>\n}\n\n`)),mdx(\"h2\",null,\"Conclusion\"),mdx(\"p\",null,\"SWR is a great library for data fetching in React, created by the same team behind Next.js, the React framework. It's a tool that i always use in every React project. I hope this post has been useful as we walked through some usage examples above.\"),mdx(\"p\",null,\"This is just the basic introduction to the library, if you want more information, check out:\"),mdx(\"ul\",null,mdx(\"li\",{parentName:\"ul\"},\"Offical document: \",mdx(\"a\",e({parentName:\"li\"},{href:\"https://swr.vercel.app\"}),\"swr.vercel.app\")),mdx(\"li\",{parentName:\"ul\"},\"Alternatives: \",mdx(\"a\",e({parentName:\"li\"},{href:\"https://react-query.tanstack.com\"}),\"React-query\"))))}MDXContent.isMDXComponent=!0;\n","scope":{}}},"__N_SSG":true}